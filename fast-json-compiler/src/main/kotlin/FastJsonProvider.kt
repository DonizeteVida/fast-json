import com.google.devtools.ksp.KspExperimental
import com.google.devtools.ksp.getAnnotationsByType
import com.google.devtools.ksp.processing.*
import com.google.devtools.ksp.symbol.*
import com.squareup.kotlinpoet.*
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
import com.squareup.kotlinpoet.ksp.toClassName
import com.squareup.kotlinpoet.ksp.writeTo
import kotlin.reflect.KClass
import org.json.JSONObject

class FastJsonProvider : SymbolProcessorProvider {
    override fun create(environment: SymbolProcessorEnvironment): SymbolProcessor =
        FastJsonProcessor(environment)
}

class FastJsonProcessor(
    private val environment: SymbolProcessorEnvironment
) : SymbolProcessor {
    override fun process(resolver: Resolver): List<KSAnnotated> {
        val fastJsonVisitor = FastJsonVisitor(environment.codeGenerator, environment.logger)

        resolver.forEach<KSFunctionDeclaration>(JsonType::class) {
            it.accept(fastJsonVisitor, Unit)
        }

        return emptyList()
    }
}

class FastJsonVisitor(
    private val codeGenerator: CodeGenerator,
    private val kspLogger: KSPLogger
) : KSVisitorVoid() {

    sealed interface Param {
        val name: String
        val packageName: String
        val type: String

        data class Primitive(
            override val name: String,
            override val packageName: String,
            override val type: String
        ) : Param

        data class Complex(
            override val name: String,
            override val packageName: String,
            override val type: String
        ) : Param
    }

    override fun visitFunctionDeclaration(function: KSFunctionDeclaration, data: Unit) {
        val packageName = function.packageName.getShortName()
        val type = function.returnType?.resolve()?.declaration ?: throw IllegalStateException("Return type could not be recovered")
        val name = type.simpleName.getShortName()
        val parserName = "${name}Parser"
        val params = getFunctionParams(function)

        FileSpec.builder(packageName, name).apply {
            addFileComment("Generated by FastJson - Do not edit it!")
            addType(
                TypeSpec.objectBuilder(
                    parserName
                ).apply {
                    addImport(packageName, name)
                    addSuperinterface(
                        parser.parameterizedBy(
                            ClassName(packageName, name)
                        )
                    )
                    addFunction(
                        FunSpec.builder("invoke").apply {
                            addModifiers(
                                KModifier.OVERRIDE,
                                KModifier.OPERATOR
                            )
                            addParameter(
                                "jsonObject", JSONObject::class
                            )
                            val str = StringBuilder().apply {
                                append("return $name(")
                                params.forEach {
                                    when (it) {
                                        is Param.Primitive -> {
                                            //jsonObject.getString("key")
                                            append("jsonObject.get${it.type}(\"${it.name}\"), ")
                                        }
                                        is Param.Complex -> {
                                            addImport(it.packageName, "${it.name}Parser")
                                        }
                                    }
                                }
                                append(")")
                            }.toString()
                            addStatement(str)
                        }.build()
                    )
                }.build()
            )
        }.build().writeTo(codeGenerator, Dependencies(false))
    }

    private fun getFunctionParams(function: KSFunctionDeclaration): List<Param> =
        function.parameters.map {
            val declaration = it.type.resolve().declaration
            val isPrimitive = declaration.containingFile == null
            val annotation = it.asAnnotations<JsonField>().firstOrNull()

            if (isPrimitive) {
                Param.Primitive(
                    name = annotation?.name ?: it.name!!.getShortName(),
                    packageName = declaration.packageName.getShortName(),
                    type = declaration.simpleName.getShortName()
                )
            } else {
                Param.Complex(
                    name = annotation?.name ?: it.name!!.getShortName(),
                    packageName = declaration.packageName.getShortName(),
                    type = declaration.simpleName.getShortName()
                )
            }
        }
}

val parser = Parser::class.asClassName()

inline fun <reified T : Any> Resolver.forEach(clazz: KClass<*>, consumer: (T) -> Unit) =
    getSymbolsWithAnnotation(clazz.qualifiedName!!).forEachInstance(consumer)

inline fun <reified T : Any> Sequence<Any>.forEachInstance(consumer: (T) -> Unit) =
    forEach {
        if (it is T) consumer(it)
    }

@OptIn(KspExperimental::class)
private inline fun <reified T : Annotation> KSValueParameter.asAnnotations() = getAnnotationsByType(T::class)