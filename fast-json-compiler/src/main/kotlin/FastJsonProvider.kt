import com.google.devtools.ksp.KspExperimental
import com.google.devtools.ksp.getAnnotationsByType
import com.google.devtools.ksp.processing.*
import com.google.devtools.ksp.symbol.KSAnnotated
import com.google.devtools.ksp.symbol.KSFunctionDeclaration
import com.google.devtools.ksp.symbol.KSValueParameter
import com.google.devtools.ksp.symbol.KSVisitorVoid
import com.squareup.kotlinpoet.*
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
import com.squareup.kotlinpoet.ksp.writeTo
import org.json.JSONObject
import kotlin.reflect.KClass

class FastJsonProvider : SymbolProcessorProvider {
    override fun create(environment: SymbolProcessorEnvironment): SymbolProcessor =
        FastJsonProcessor(environment)
}

class FastJsonProcessor(
    private val environment: SymbolProcessorEnvironment
) : SymbolProcessor {
    override fun process(resolver: Resolver): List<KSAnnotated> {
        val fastJsonVisitor = FastJsonVisitor(environment.codeGenerator, environment.logger)

        resolver.forEach<KSFunctionDeclaration>(JsonType::class) {
            it.accept(fastJsonVisitor, Unit)
        }

        return emptyList()
    }
}

class FastJsonVisitor(
    private val codeGenerator: CodeGenerator,
    private val kspLogger: KSPLogger
) : KSVisitorVoid() {

    override fun visitFunctionDeclaration(function: KSFunctionDeclaration, data: Unit) {
        val packageName = function.packageName.getShortName()
        val type = function.returnType?.resolve()?.declaration
            ?: throw IllegalStateException("Return type could not be recovered")
        val name = type.simpleName.getShortName()
        val parserName = "${name}Parser"
        val params = getFunctionParams(function)

        FileSpec.builder(packageName, name).apply {
            addFileComment("Generated by FastJson - Do not edit it!")
            addType(
                TypeSpec.objectBuilder(
                    parserName
                ).apply {
                    addImport(packageName, name)
                    params.forEach {
                        it.additionalImports.forEach {(packageName, name) ->
                            addImport(packageName, name)
                        }
                    }
                    addSuperinterface(
                        parser.parameterizedBy(
                            ClassName(packageName, name)
                        )
                    )
                    addFunction(
                        FunSpec.builder("invoke").apply {
                            addModifiers(
                                KModifier.OVERRIDE,
                                KModifier.OPERATOR
                            )
                            addParameter(
                                "jsonObject", JSONObject::class
                            )
                            StringBuilder().apply {
                                append("return $name(")
                                append(params.joinToString(", "))
                                append(")")
                            }.toString().also(::addStatement)
                        }.build()
                    )
                }.build()
            )
        }.build().writeTo(codeGenerator, Dependencies(false))
    }

    private fun getFunctionParams(function: KSFunctionDeclaration): List<Param> =
        function.parameters.map {
            val declaration = it.type.resolve().declaration
            val isPrimitive = declaration.containingFile == null
            val annotation = it.asAnnotations<JsonField>().firstOrNull()

            val typeArguments = it.type.element?.typeArguments ?: emptyList()

            val name = annotation?.name ?: it.name!!.getShortName()
            val packageName = declaration.packageName.getShortName()
            val type = declaration.simpleName.getShortName()

            //Some generic shit
            if (isPrimitive and typeArguments.isNotEmpty()) {
                val argument = typeArguments.first()
                val declaration = argument.type?.resolve()?.declaration ?: throw IllegalStateException("Declaration not found")
                val type = declaration.simpleName.getShortName()

                Param(
                    name = name,
                    packageName = packageName,
                    type = type,
                    invoke = """${type}Parser.asList(jsonObject.getJSONArray("$name"))"""
                )
            } else if (isPrimitive) {
                Param(
                    name = name,
                    packageName = packageName,
                    type = type,
                    invoke = """jsonObject.get$type("$name")"""
                )
            } else {
                Param(
                    name = name,
                    packageName = packageName,
                    type = type,
                    additionalImports = arrayListOf(
                        packageName to "${type}Parser"
                    ),
                    invoke = """${type}Parser(jsonObject.getJSONObject("$name"))"""
                )
            }
        }
}

data class Param(
    val name: String,
    val packageName: String,
    val type: String,
    val additionalImports: List<Pair<String, String>> = emptyList(),
    val invoke: String
) {
    override fun toString() = invoke
}

val parser = Parser::class.asClassName()

inline fun <reified T : Any> Resolver.forEach(clazz: KClass<*>, consumer: (T) -> Unit) =
    getSymbolsWithAnnotation(clazz.qualifiedName!!).forEachInstance(consumer)

inline fun <reified T : Any> Sequence<Any>.forEachInstance(consumer: (T) -> Unit) =
    forEach {
        if (it is T) consumer(it)
    }

@OptIn(KspExperimental::class)
private inline fun <reified T : Annotation> KSValueParameter.asAnnotations() = getAnnotationsByType(T::class)