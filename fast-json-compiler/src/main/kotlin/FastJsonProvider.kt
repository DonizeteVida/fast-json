import com.google.devtools.ksp.KspExperimental
import com.google.devtools.ksp.getAnnotationsByType
import com.google.devtools.ksp.processing.*
import com.google.devtools.ksp.symbol.KSAnnotated
import com.google.devtools.ksp.symbol.KSFunctionDeclaration
import com.google.devtools.ksp.symbol.KSValueParameter
import com.google.devtools.ksp.symbol.KSVisitorVoid
import com.squareup.kotlinpoet.*
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
import com.squareup.kotlinpoet.ksp.writeTo
import org.json.JSONObject
import kotlin.reflect.KClass

class FastJsonProvider : SymbolProcessorProvider {
    override fun create(environment: SymbolProcessorEnvironment): SymbolProcessor =
        FastJsonProcessor(environment)
}

class FastJsonProcessor(
    private val environment: SymbolProcessorEnvironment
) : SymbolProcessor {
    override fun process(resolver: Resolver): List<KSAnnotated> {
        val fastJsonVisitor = FastJsonVisitor(environment.codeGenerator, environment.logger)

        resolver.forEach<KSFunctionDeclaration>(JsonType::class) {
            it.accept(fastJsonVisitor, Unit)
        }

        return emptyList()
    }
}

class FastJsonVisitor(
    private val codeGenerator: CodeGenerator,
    private val kspLogger: KSPLogger
) : KSVisitorVoid() {

    override fun visitFunctionDeclaration(function: KSFunctionDeclaration, data: Unit) {
        val packageName = function.packageName.getShortName()
        val type = function.returnType?.resolve()?.declaration
            ?: throw IllegalStateException("Return type could not be recovered")
        val name = type.simpleName.getShortName()
        val parserName = "${name}Parser"
        val params = getFunctionParams(function)

        FileSpec.builder(packageName, parserName).apply {
            addFileComment("Generated by FastJson - Do not edit it!")
            addType(
                TypeSpec.objectBuilder(
                    parserName
                ).apply {
                    addImport(packageName, name)
                    params.forEach {
                        it.additionalImports.forEach { (packageName, name) ->
                            addImport(packageName, name)
                        }
                    }
                    addSuperinterface(
                        parser.parameterizedBy(
                            ClassName(packageName, name)
                        )
                    )
                    addFunction(
                        FunSpec.builder("invoke").apply {
                            addModifiers(
                                KModifier.OVERRIDE,
                                KModifier.OPERATOR
                            )
                            addParameter(
                                "jsonObject", JSONObject::class
                            )
                            StringBuilder().apply {
                                append("return $name(")
                                append(params.joinToString(", "))
                                append(")")
                            }.toString().also(::addStatement)
                        }.build()
                    )
                }.build()
            )
        }.build().writeTo(codeGenerator, Dependencies(false))
    }

    private fun getFunctionParams(function: KSFunctionDeclaration): List<Param> =
        function.parameters.map {
            val declaration = it.type.resolve().declaration

            //external type means it is not our code and probably
            //isn't annotated: List, Map, Set
            val isExternalType = declaration.containingFile == null
            val annotation = it.asAnnotations<JsonField>().firstOrNull()

            val typeArguments = it.type.element?.typeArguments ?: emptyList()

            val name = annotation?.name ?: it.name!!.getShortName()
            val packageName = declaration.packageName.getShortName()
            val type = declaration.simpleName.getShortName()

            if (isExternalType) {
                if (typeArguments.isNotEmpty()) {
                    when (typeArguments.size) {
                        //probably a list or set
                        1 -> {
                            val argument = typeArguments.first()
                            val declaration = argument.type?.resolve()?.declaration ?: throw IllegalStateException("Declaration not found")
                            val innerType = declaration.simpleName.getShortName()
                            Param(
                                invoke = """${innerType}Parser.as${type}(jsonObject.getJSONArray("$name"))"""
                            )
                        }
                        //A map, probably
                        2 -> {
                            val arg1 = typeArguments[0]
                            val arg2 = typeArguments[1]

                            val dec1 = arg1.type?.resolve()?.declaration ?: throw IllegalStateException("Declaration not found")
                            val dec2 = arg2.type?.resolve()?.declaration ?: throw IllegalStateException("Declaration not found")

                            val innerType = dec2.simpleName.getShortName()

                            if (dec1.simpleName.getShortName() != "String") throw IllegalStateException("Map type $dec1 not supported")

                            Param(
                                invoke = """${innerType}Parser.as${type}(jsonObject.getJSONObject("$name"))"""
                            )
                        }
                        else -> throw IllegalStateException("Item is not supported")
                    }
                } else {
                    Param(
                        invoke = """jsonObject.get$type("$name")"""
                    )
                }
            } else {
                Param(
                    additionalImports = arrayListOf(
                        packageName to "${type}Parser"
                    ),
                    invoke = """${type}Parser(jsonObject.getJSONObject("$name"))"""
                )
            }
        }
}

data class Param(
    val additionalImports: List<Pair<String, String>> = emptyList(),
    val invoke: String
) {
    override fun toString() = invoke
}

val parser = Parser::class.asClassName()

inline fun <reified T : Any> Resolver.forEach(clazz: KClass<*>, consumer: (T) -> Unit) =
    getSymbolsWithAnnotation(clazz.qualifiedName!!).forEachInstance(consumer)

inline fun <reified T : Any> Sequence<Any>.forEachInstance(consumer: (T) -> Unit) =
    forEach {
        if (it is T) consumer(it)
    }

@OptIn(KspExperimental::class)
private inline fun <reified T : Annotation> KSValueParameter.asAnnotations() = getAnnotationsByType(T::class)