import com.google.devtools.ksp.KspExperimental
import com.google.devtools.ksp.getAnnotationsByType
import com.google.devtools.ksp.processing.*
import com.google.devtools.ksp.symbol.KSAnnotated
import com.google.devtools.ksp.symbol.KSFunctionDeclaration
import com.google.devtools.ksp.symbol.KSValueParameter
import com.google.devtools.ksp.symbol.KSVisitorVoid
import com.squareup.kotlinpoet.*
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
import com.squareup.kotlinpoet.ksp.writeTo
import kotlin.reflect.KClass

class FastJsonProvider : SymbolProcessorProvider {
    override fun create(environment: SymbolProcessorEnvironment): SymbolProcessor =
        FastJsonProcessor(environment)
}

class FastJsonProcessor(
    private val environment: SymbolProcessorEnvironment
) : SymbolProcessor {
    override fun process(resolver: Resolver): List<KSAnnotated> {
        val fastJsonVisitor = FastJsonVisitor(environment.codeGenerator, environment.logger)

        resolver.forEach<KSFunctionDeclaration>(JsonType::class) {
            it.accept(fastJsonVisitor, Unit)
        }

        return emptyList()
    }
}

class FastJsonVisitor(
    private val codeGenerator: CodeGenerator,
    private val kspLogger: KSPLogger
) : KSVisitorVoid() {

    override fun visitFunctionDeclaration(function: KSFunctionDeclaration, data: Unit) {
        val packageName = function.packageName.getShortName()
        val type = function.returnType?.resolve()?.declaration
            ?: throw IllegalStateException("Return type could not be recovered")
        val name = type.simpleName.getShortName()
        val parserName = "${name}Parser"
        val params = getFunctionParams(function)

        FileSpec.builder(packageName, parserName).apply {
            addFileComment("Generated by FastJson - Do not edit it!")
            addType(
                TypeSpec.objectBuilder(
                    parserName
                ).apply {
                    addImport(packageName, name)
                    params.forEach {
                        it.additionalImports.forEach { (packageName, name) ->
                            addImport(packageName, name)
                        }
                    }
                    addSuperinterface(
                        Parser::class.asClassName().parameterizedBy(
                            ClassName(packageName, name)
                        )
                    )
                    addFunction(
                        FunSpec.builder("invoke").apply {
                            addModifiers(
                                KModifier.OVERRIDE,
                                KModifier.OPERATOR
                            )
                            addParameter(
                                "obj", JsonObjectWrapper::class
                            )
                            StringBuilder().apply {
                                append("return $name(")
                                append(params.map(Param::fromJson).joinToString(", "))
                                append(")")
                            }.toString().also(::addStatement)
                        }.build()
                    )

                    addFunction(
                        FunSpec.builder("invoke").apply {
                            addModifiers(
                                KModifier.OVERRIDE,
                                KModifier.OPERATOR
                            )
                            addParameter(
                                "obj", ClassName(packageName, name)
                            )
                            StringBuilder().apply {
                                append("return JsonObjectWrapper().apply {\n")
                                append(params.map(Param::toJson).joinToString("\n"))
                                append("\n}")
                            }.toString().also(::addStatement)
                        }.build()
                    )
                }.build()
            )
        }.build().writeTo(codeGenerator, Dependencies(true))
    }

    private fun getFunctionParams(function: KSFunctionDeclaration): List<Param> =
        function.parameters.map {
            val declaration = it.type.resolve().declaration

            //external type means it is not our code and probably
            //isn't annotated: List, Map, Set
            val isExternalType = declaration.containingFile == null
            val annotation = it.asAnnotations<JsonField>().firstOrNull()

            val typeArguments = it.type.element?.typeArguments ?: emptyList()

            val paramName = it.name!!.getShortName()
            val key = annotation?.name ?: paramName
            val packageName = declaration.packageName.getShortName()
            val type = declaration.simpleName.getShortName()

            if (isExternalType) {
                if (typeArguments.isNotEmpty()) {
                    when (typeArguments.size) {
                        //probably a list or set
                        1 -> {
                            val argument = typeArguments.first()
                            val declaration = argument.type?.resolve()?.declaration
                                ?: throw IllegalStateException("Declaration not found")
                            val innerType = declaration.simpleName.getShortName()
                            Param(
                                fromJson = """${innerType}Parser.as${type}(obj.getArray("$key"))""",
                                toJson = """putArray("$key", ${innerType}Parser.toJson(obj.$paramName))"""
                            )
                        }
                        //A map, probably
                        2 -> {
                            val arg1 = typeArguments[0]
                            val arg2 = typeArguments[1]

                            val dec1 = arg1.type?.resolve()?.declaration
                                ?: throw IllegalStateException("Declaration not found")
                            val dec2 = arg2.type?.resolve()?.declaration
                                ?: throw IllegalStateException("Declaration not found")

                            val innerType = dec2.simpleName.getShortName()

                            Param(
                                fromJson = """${innerType}Parser.as${type}(obj.getObject("$key"))""",
                                toJson = """putObject("$key", ${type}Parser(obj.$paramName))"""
                            )
                        }
                        else -> throw IllegalStateException("Item is not supported")
                    }
                } else {
                    Param(
                        fromJson = """obj.get$type("$key")""",
                        toJson = """put$type("$key", obj.$paramName)"""
                    )
                }
            } else {
                Param(
                    additionalImports = arrayListOf(
                        packageName to "${type}Parser"
                    ),
                    fromJson = """${type}Parser(obj.getObject("$key"))""",
                    toJson = """putObject("$key", ${type}Parser(obj.$paramName))"""
                )
            }
        }
}

data class Param(
    val additionalImports: List<Pair<String, String>> = emptyList(),
    val fromJson: String,
    val toJson: String
)

inline fun <reified T : Any> Resolver.forEach(clazz: KClass<*>, consumer: (T) -> Unit) =
    getSymbolsWithAnnotation(clazz.qualifiedName!!).forEachInstance(consumer)

inline fun <reified T : Any> Sequence<Any>.forEachInstance(consumer: (T) -> Unit) =
    forEach {
        if (it is T) consumer(it)
    }

@OptIn(KspExperimental::class)
private inline fun <reified T : Annotation> KSValueParameter.asAnnotations() = getAnnotationsByType(T::class)